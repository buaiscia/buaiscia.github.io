{"pageProps":{"post":{"mdxSource":"var Component=(()=>{var l=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,d=Object.prototype.hasOwnProperty;var c=a=>o(a,\"__esModule\",{value:!0});var u=(a,s)=>()=>(s||a((s={exports:{}}).exports,s),s.exports),k=(a,s)=>{c(a);for(var t in s)o(a,t,{get:s[t],enumerable:!0})},N=(a,s,t)=>{if(s&&typeof s==\"object\"||typeof s==\"function\")for(let n of h(s))!d.call(a,n)&&n!==\"default\"&&o(a,n,{get:()=>s[n],enumerable:!(t=p(s,n))||t.enumerable});return a},g=a=>N(c(o(a!=null?l(m(a)):{},\"default\",a&&a.__esModule&&\"default\"in a?{get:()=>a.default,enumerable:!0}:{value:a,enumerable:!0})),a);var i=u((j,r)=>{r.exports=_jsx_runtime});var b={};k(b,{default:()=>y,frontmatter:()=>f});var e=g(i()),f={title:\"Developer Tips - July 2022\",date:\"2022-07-22\",draft:!1,tags:[\"web development\",\"react\",\"tips\"],summary:\"Development tips for the month of July: Formik forms validation errors, Memoize a React component\"};function w(a={}){let{wrapper:s}=a.components||{};return s?(0,e.jsx)(s,Object.assign({},a,{children:(0,e.jsx)(t,{})})):t();function t(){let n=Object.assign({h3:\"h3\",a:\"a\",span:\"span\",p:\"p\",pre:\"pre\",code:\"code\"},a.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.h3,{id:\"sending-errors-through-a-formik-form\",children:[(0,e.jsx)(n.a,{href:\"#sending-errors-through-a-formik-form\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Sending errors through a Formik form\"]}),(0,e.jsx)(n.p,{children:\"When we need to validate a Formik form (often with Yup) we can use the following method: validateForm. It returns a promise so we have to check if it resolves or not. However, the validation errors are sent directly inside the promise as an argument and not caught. So the promise is always resolved in this case.\"}),(0,e.jsx)(n.p,{children:\"To pass the validation error, then, we have to pass the errors as an argument of the promise itself.\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsxs)(n.code,{className:\"language-js code-highlight\",children:[(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  formik\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(n.span,{className:\"token function property-access method\",children:\"validateForm\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),(0,e.jsx)(n.span,{className:\"token operator spread\",children:\"...\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"    \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(n.span,{className:\"token function property-access method\",children:\"then\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(n.span,{className:\"token parameter\",children:\"errors\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator arrow\",children:\"=>\"}),\" \",(0,e.jsx)(n.span,{className:\"token function\",children:\"submit\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),\"formik\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),\" values\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),\" errors\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),`\n`]})]})}),(0,e.jsx)(n.p,{children:\"Then the errors can be checked and the logic can be written in the submit method.\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsx)(n.code,{className:\"language-js code-highlight\",children:(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token keyword\",children:\"const\"}),\" \",(0,e.jsx)(n.span,{className:\"token function function-variable\",children:\"submit\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"=\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsxs)(n.span,{className:\"token parameter\",children:[\"formik\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),\" values\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),\" errors\"]}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator arrow\",children:\"=>\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),(0,e.jsx)(n.span,{className:\"token operator spread\",children:\"...\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"}),`\n`]})})}),(0,e.jsx)(n.p,{children:\"Bonus: here are the types (for TS users) for the 3 arguments above:\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsxs)(n.code,{className:\"language-js code-highlight\",children:[(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"formik\",(0,e.jsx)(n.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"FormikContextType\"}),(0,e.jsx)(n.span,{className:\"token operator\",children:\"<\"}),(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"FormikValues\"}),(0,e.jsx)(n.span,{className:\"token operator\",children:\">\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"values\",(0,e.jsx)(n.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"FormikValues\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"errors\",(0,e.jsx)(n.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"FormikErrors\"}),(0,e.jsx)(n.span,{className:\"token operator\",children:\"<\"}),(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"FormikValues\"}),(0,e.jsx)(n.span,{className:\"token operator\",children:\">\"}),`\n`]})]})}),(0,e.jsx)(n.p,{children:(0,e.jsx)(n.a,{href:\"https://github.com/buaiscia/Notes/blob/main/2022/07/22.md\",children:\"GitHub gist\"})}),(0,e.jsxs)(n.h3,{id:\"memoize-a-react-component\",children:[(0,e.jsx)(n.a,{href:\"#memoize-a-react-component\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Memoize a React component\"]}),(0,e.jsx)(n.p,{children:\"Memoization is a feature in React. The library compares (in a shallow way) two versions of an object and, if they are the same, does not re-render (or recompile) it, creating an optimization in performance and memory.\"}),(0,e.jsx)(n.p,{children:\"The React.memo higher order component (to notice, not useMemo) used on a component is very easy to implement, but it's not always efficient or necessary. As everything about memoization in React, we shouldn't memoize everything but just the objects that are heavy, big, or re-renders very often.\"}),(0,e.jsx)(n.p,{children:\"So in my job it happened an interesting case. I had quite a big parent component that is wrapping inside smaller children components. I'll just change the type of subjects and component name, but the example I'm giving is the same I have.\"}),(0,e.jsx)(n.p,{children:\"How do we memoize a component?\"}),(0,e.jsx)(n.p,{children:\"Supposing we have:\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsx)(n.code,{className:\"language-js code-highlight\",children:(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token keyword\",children:\"const\"}),\" \",(0,e.jsx)(n.span,{className:\"token function function-variable\",children:(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"BigComponent\"})}),\" \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"=\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsxs)(n.span,{className:\"token parameter\",children:[(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),(0,e.jsx)(n.span,{className:\"token operator spread\",children:\"...\"}),\"lots \",(0,e.jsx)(n.span,{className:\"token keyword\",children:\"of\"}),\" props\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"})]}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator arrow\",children:\"=>\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),(0,e.jsx)(n.span,{className:\"token operator spread\",children:\"...\"}),\"lots \",(0,e.jsx)(n.span,{className:\"token keyword\",children:\"of\"}),\" stuff done\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"}),`\n`]})})}),(0,e.jsx)(n.p,{children:\"then we just put memo on the export\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsx)(n.code,{className:\"language-js code-highlight\",children:(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token keyword module\",children:\"export\"}),\" \",(0,e.jsx)(n.span,{className:\"token keyword module\",children:\"default\"}),\" \",(0,e.jsx)(n.span,{className:\"token function\",children:\"memo\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"BigComponent\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),`\n`]})})}),(0,e.jsx)(n.p,{children:\"Is it enough? Sometimes yes. But the more interesting part is another. How does React knows what to compare? It takes a previous version, and a next version (the one we're updating with new props). In the same way, memo could use those two version as callback arguments. They can be checked to make a quicker comparison, speeding up even more the memoization process.\"}),(0,e.jsx)(n.p,{children:\"Supposing that our BigComponent is mostly managing a school student card, and we have the children components showing according to the student. Then we'll have BigComponent supposedly changing when the id of the student change (supposing that is mapped from a parent component).\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsx)(n.code,{className:\"language-js code-highlight\",children:(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token keyword\",children:\"const\"}),\" \",(0,e.jsx)(n.span,{className:\"token function function-variable\",children:(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"BigComponent\"})}),\" \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"=\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsxs)(n.span,{className:\"token parameter\",children:[(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),\"student\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator spread\",children:\"...\"}),\"other props\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"})]}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator arrow\",children:\"=>\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),(0,e.jsx)(n.span,{className:\"token operator spread\",children:\"...\"}),\"lots \",(0,e.jsx)(n.span,{className:\"token keyword\",children:\"of\"}),\" stuff done\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"}),`\n`]})})}),(0,e.jsx)(n.p,{children:\"We can now memoize the component comparing the IDs of the student. We can think of the IDs as the keys of the object. If they're the same, the component will remain the same, otherwise it will re-render.\"}),(0,e.jsx)(n.p,{children:\"But as you can see, I've done it slightly differently!\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsx)(n.code,{className:\"language-js code-highlight\",children:(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token keyword module\",children:\"export\"}),\" \",(0,e.jsx)(n.span,{className:\"token keyword module\",children:\"default\"}),\" \",(0,e.jsx)(n.span,{className:\"token function\",children:\"memo\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"BigComponent\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsxs)(n.span,{className:\"token parameter\",children:[\"prev\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),\" next\"]}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator arrow\",children:\"=>\"}),\" prev\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(n.span,{className:\"token property-access\",children:\"student\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(n.span,{className:\"token property-access\",children:\"id\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"!==\"}),\" next\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(n.span,{className:\"token property-access\",children:\"student\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(n.span,{className:\"token property-access\",children:\"id\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),`\n`]})})}),(0,e.jsx)(n.p,{children:\"This above will say: if the previous ID is different comparing to the next one, return true. The problem here is that we're getting the props and we use them on a child component, so if the IDs are the same (===) it won't do anything (won't open the card).\"}),(0,e.jsx)(n.p,{children:\"In my case, it checks that the IDs are different, and don't do anything. But if they're the same, it'll allow the rerender. It's similar to how ShouldComponentUpdate was working, as we're giving the condition on when to rerender.\"}),(0,e.jsx)(n.p,{children:\"So, to sum up, we're memoizing (not rerendering) this component the opposite way only when the IDs (keys) change. That means that when we open a student card it will rerender. But when we add more students, or we use other student cards, they won't rerender in the page, and we will be getting a performance improvement.\"}),(0,e.jsx)(n.p,{children:(0,e.jsx)(n.a,{href:\"https://github.com/buaiscia/Notes/blob/main/2022/07/27.md\",children:\"Github gist\"})})]})}}var y=w;return b;})();\n;return Component;","toc":[{"value":"Sending errors through a Formik form","url":"#sending-errors-through-a-formik-form","depth":3},{"value":"Memoize a React component","url":"#memoize-a-react-component","depth":3}],"frontMatter":{"readingTime":{"text":"4 min read","minutes":3.93,"time":235800,"words":786},"slug":"july-2022-tips","fileName":"july-2022-tips.md","title":"Developer Tips - July 2022","date":"2022-07-22T00:00:00.000Z","draft":false,"tags":["web development","react","tips"],"summary":"Development tips for the month of July: Formik forms validation errors, Memoize a React component"}},"authorDetails":[{"readingTime":{"text":"1 min read","minutes":0.94,"time":56400,"words":188},"slug":["default"],"fileName":"default.md","name":"Alex Buaiscia","avatar":"/static/images/avatar.png","occupation":"Full-stack Software Developer","company":"Moravio","twitter":"https://twitter.com/AlexBuaiscia","linkedin":"https://www.linkedin.com/in/alex-buaiscia/","github":"https://github.com/buaiscia","date":null}],"prev":{"title":"How I passed from Junior to Intermediate developer in one year","date":"2021-12-15T00:00:00.000Z","draft":false,"tags":["insights"],"summary":"Learning from going above junior is not easy. This is why I think I did it and what I could learn in this passage","slug":"how-passed-from-junior-to-intermediate-dev-one-year"},"next":null},"__N_SSG":true}