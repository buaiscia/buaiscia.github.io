{"pageProps":{"post":{"mdxSource":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"-- in controlled components value is changed/updated by state and uncontrolled by event handlers\"), mdx(\"h2\", {\n    \"id\": \"1---usestate\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#1---usestate\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"1 - useState\"), mdx(\"p\", null, \"THe interesting part of useState is how under the hood is nothing else but an array declaration. When it's used, it gets two elements of the array, in which the first is the variable and the second one is the function to update the variable.\\nSo a code like this:\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const [ count, setCount ] = useState(0)\"), \"\\nnot destructured:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const array = useState(0)\\nconst count = array[0]\\nconst setCount = array[1]\\n\")), mdx(\"p\", null, \"The first exercise is quite simple if one understands React states well. Everytime (unless different specified) the state changes, in any part of the component, there will be a re-render (of the page or component depending) of the virtual DOM hence updating what appears on the page.\\nIf I call a function on the onChange in the input, and that function changes the state (setCount(event.target.value)), then I can call the updated state in any part of the render\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \" {count ? <strong>Count is {count}</strong> : 'Add a number to count'}\")), mdx(\"p\", null, \"In the second part the task would be to use a prop in the component as initial value to pass\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Counting initialCount=0\"), \"\\nI find there are different ways. The best way is to setState to that initial value that is destructured in the function arguments:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function Counting({ initialCount = 0 })\\n\")), mdx(\"p\", null, \"Destructuring is necessary because initial name is an object so, if passing the argument just like (initialCount), the result will be a \", \"[Object object]\", \".\\nThe default value (= '') is also necessary in case we don't pass anything as a prop. In this case we don't cause a crash because of undefined value.\\nSo one way is to setState(initialCount) and value=count in the input.\"), mdx(\"p\", null, \"Another possible way is to set the defaultValue of the input to the initialCount. This will have the same effect except that the state of the rendered text won't be updated until something is typed. It's possible to create a check to use the count (like a nested if but with ternary operator). However, it will make the code more difficult to read and follow in its flow.\"), mdx(\"h2\", {\n    \"id\": \"2---useeffect\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#2---useeffect\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"2 - useEffect\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"it's called every render of the component, including the first and every time the state changes\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"to persist the state, call the localstorage methods inside useEffect \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const [name, setName] = React.useState(window.localStorage.getItem('name') || initialName)\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"localStorage performance issue - slow\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"React\\u2019s useState hook allows you to pass a function instead of the actual value, and then it will only call that function to get the state value when the component is rendered the first time: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"React.useState(() => someExpensiveComputation())\"), \" ... that's the same as the callback on setState in class components\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"lazy initialization = not reading from localStorage every render\\n--> create a callback function: useEffect\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const [name, setName] = React.useState(() => window.localStorage.getItem('name') || initialName)\"), \"\\nIf we put a console inside the callback we cans see it's called only on the first render\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"To be used only for bottleneck functions that require sync time\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"dependency array: second argument on useEffect which signals to React that your effect callback function should be called when (and only when) those dependencies change:\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"React.useEffect(() => {\\n    window.localStorage.setItem('count', count)\\n  }, [name])\\n\")), mdx(\"p\", null, \"if other states apart fron name change setItem won't be called\\nIf left empty it's like never use useEffect with any state with useEffect\\nThe state in the dependency array is an object that is compared on the render with the previous state with object comparation. If it's the same won't run useEffect, otherwise yes.\"), mdx(\"p\", null, \"Custom hooks: external function called inside the hook whose name starts with \\u201Duse\\u201D.\\nIf we have different functions inside the compoenent method we can externilize those, even useEffect:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function Greeting({ initialCount = 0 }) {\\n  const [count, setCount] = React.useState(\\n    () => window.localStorage.getItem('count') || initialCount,\\n  )\\n\\n  React.useEffect(() => {\\n    window.localStorage.setItem('count', count)\\n  }, [count])\\n\\n  function handleChange(event) {\\n    setCount(event.target.value)\\n  }\\n\")), mdx(\"p\", null, \"to -->\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function useLocalStorageWithState() {\\n  const [count, setCount] = React.useState(\\n    () => window.localStorage.getItem('count') || initialCount,\\n  )\\n\\n  React.useEffect(() => {\\n    window.localStorage.setItem('count', count)\\n  }, [count])\\n\\n  return [count, setCount];\\n}\\n\\nfunction Greeting({ initialCount= 0 }) {\\n  const [count, setCount] = useLocalStorageWithState()\\n  function handleChange(event) {\\n    setCount(event.target.value)\\n  }\\n\")), mdx(\"p\", null, \"Setting up a callback inside useState makes the setting of the state as lazy, as it compares the states and doesn't change it if it's the same.\"), mdx(\"p\", null, \"Getting the error React Hook ... is called in function ... which is neither a React function component or custom React Hook function?\\nIt's because of a React convention, it just means that your function doesn't start with use. Yes, that's it! A custom hook must start with use!\\nSo, instead of syncLocalStorageWithState, we call it useLocalStorageWithState.\"), mdx(\"p\", null, \"useLocalStorageWithState should have the same use as the useState hook, so it can return an array like useState, and we can store in a same array. So we have created a customed useState hook that does other stuff as well.\\nWe pass as well count and initialCount as parameters \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useLocalStorageWithState(count, initialCount)\"), \" and then making useLocalStorageWithState more generic, receiving as arguments \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"key, defaultValue\"), \" , so the method can be reused freely and not stay chained to a count state. The same applies to the state. We can set \", \"[state, setState]\", \" and return the same.\\nHaving two arguments means that also useEffect should have two in the dependency array.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"flexible localStorage hook. This was the most complex part of the workshop to think about. The solution is not so complicated, but to be honest I couldn't manage until checking the video how to make this logic work (ok maybe it's because I'm tired \\uD83D\\uDE05)\\nAnd the logic is the following:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"get the item from local storage\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if present, JSON parse it and return the result\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if not, return the default value\")))), mdx(\"p\", null, \"That's for setting the state; for making the changes (useEffect), in this case for creating/editing the local storage, once the state changes we can just stringify whatever the state will be and store it.\\nSerialize will be for stringify the JSON, while deserialize for parsing it.\"), mdx(\"p\", null, \"In case as argument of useLocalStorageWithState, instead of a number, we'll pass a function, it's possible to create a check to return the results of another function.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const [name, setName] = useLocalStorageWithState('name', complexCounting() )\"), \" --> pass a function as default value\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"return typeof defaultValue === 'function' ? defaultValue() : defaultValue;\"), \" --> return to useState the result of the method\"), mdx(\"p\", null, \"Then it comes the complicated part. The case is what if somebody wants to pass another value to the 'key'? Now it's passed 'count' as string, but maybe somebody will change it.\\nThere's no direct way to change the state of the key, so what is done is store the key into a var that won't trigger the render, using useRef. Following that, in useEffect we can compare the old key with the new one.\"), mdx(\"p\", null, \"According to the docs:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"useRef returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component.\\nNote that useRef() is useful for more than the ref attribute. It\\u2019s handy for keeping any mutable value around similar to how you\\u2019d use instance fields in classes.\")), mdx(\"p\", null, \"The difference with useState is then that useRef doesn't trigger a rerender, so with this hook we can actually set the key without triggering the rerender. The purpose of this is clear in the useEffect.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const prevKey = prevKeyRef.current;\\n    if (prevKey !== key) {\\n      window.localStorage.removeItem(prevKey)\\n    }\\n\")), mdx(\"p\", null, \"That means that usually we store in localStorage a value. But this value is in an object, and that object has a key. So for now it's 'count'. But if it will be 'sum', and we don't remove the initial key, we'll have two objects in localStorage. So if the new key and the old one, which is stored in the useRef var, is different, we will remove the obect in localStorage with the old key.\"), mdx(\"h2\", {\n    \"id\": \"3---lifting-and-colocating-state\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#3---lifting-and-colocating-state\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"3 - Lifting and Colocating state\"), mdx(\"p\", null, \"Lifting state is when you have state managed inside a component but a parent component needs it to render it or display it somewhere else.\\nSo when it's needed to lifting state, we take that state and find the least common parent between the two components. So the state is lifted from a lower branch of the family -or the tree- to a higher one.\"), mdx(\"p\", null, \"Colocating state, instead, is to place the state management the furthest down the tree as possible where not shared by a parent component. A state correctly colocated helps React to not having to render the whole application for just, for example, an input change.\\nIf a state is used only by a component up the tree, it's probably possible to refactor it colocating the state in the sibling component that is managing it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"  const [name, setName] = React.useState('')\\n  const [animal, setAnimal] = React.useState('')\\n  return (\\n      <Name name={name} onNameChange={event => setName(event.currentTarget.value)} />\\n      <FavoriteAnimal animal={animal} onAnimalChange={event => setAnimal(event.currentTarget.value)} />\\n      <Display animal={animal} />\\n  )\\n\")), mdx(\"p\", null, \"In the above case, for example, the animal state was lifted to the parent component as it's used by the Display component as well. But the name state is not used, so it can be colocated to Name component only. This will result like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function Name() {\\n  const [name, setName] = React.useState('')\\n\\n  return (\\n    <div>\\n      <label htmlFor=\\\"name\\\">Name: </label>\\n      <input id=\\\"name\\\" value={name} onChange={event => setName(event.currentTarget.value)} />\\n    </div>\\n  )\\n}\\n\\nconst [animal, setAnimal] = React.useState('')\\n  return (\\n    <form>\\n      <Name />\\n      <FavoriteAnimal animal={animal} onAnimalChange={event => setAnimal(event.currentTarget.value)} />\\n      <Display animal={animal} />\\n  )\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"set local storage is a side effect as it's an async function, so it's required to be inside useEffect\")), mdx(\"h2\", {\n    \"id\": \"4---manipulating-the-dom-via-react\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#4---manipulating-the-dom-via-react\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"4 - Manipulating the DOM via React\"), mdx(\"p\", null, \"As there's no direct access to the DOM via React, this can be done via Refs\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function MyDiv() {\\n  const myDivRef = React.useRef()\\n  React.useEffect(() => {\\n    const myDiv = myDivRef.current\\n    // myDiv is the div DOM node!\\n    console.log(myDiv)\\n    // DO some action\\n    return // cancel events at the unmounting of the component (garbage collected)\\n  }, [])\\n  return <div ref={myDivRef}>hi</div>\\n}\\n\")), mdx(\"p\", null, \"Once the component is mounted, useEffect will run and store into the myDiv const the current value of the DOM node of the div.\\nIn this case we leave an empty dependency array as it doesn't depend on the state of the app, so it happens once only.\"), mdx(\"h2\", {\n    \"id\": \"5---http-requests\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#5---http-requests\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"5 - HTTP requests\"), mdx(\"p\", null, \"One has to be careful in calling async functions inside useEffect, because it can't be done directly as they'll return promises instead of data or the results.\\nIt has to be done via callback, either inside the useEffect, of externalizing it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"React.useEffect(() => {\\n  async function effect() {   // creating inside the callback the async method\\n    const result = await doSomeAsyncThing() // call the async function\\n  }\\n  effect()  // calling the method as callback (so no promise will return, but the actual results)\\n})\\n\")), mdx(\"p\", null, \"The other way is creating the function outside useEffect and calling it inside as callback\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"React.useEffect(() => {\\n  doSomeAsyncThing().then(result => {\\n  })\\n})\\n\")));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>-- in controlled components value is changed/updated by state and uncontrolled by event handlers</p><h2 id=\"1---usestate\"><a href=\"#1---usestate\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>1 - useState</h2><p>THe interesting part of useState is how under the hood is nothing else but an array declaration. When it&#x27;s used, it gets two elements of the array, in which the first is the variable and the second one is the function to update the variable.\nSo a code like this:\n<code>const [ count, setCount ] = useState(0)</code>\nnot destructured:</p><pre><code>const array = useState(0)\nconst count = array[0]\nconst setCount = array[1]\n</code></pre><p>The first exercise is quite simple if one understands React states well. Everytime (unless different specified) the state changes, in any part of the component, there will be a re-render (of the page or component depending) of the virtual DOM hence updating what appears on the page.\nIf I call a function on the onChange in the input, and that function changes the state (setCount(event.target.value)), then I can call the updated state in any part of the render\n<code> {count ? &lt;strong&gt;Count is {count}&lt;/strong&gt; : &#x27;Add a number to count&#x27;}</code></p><p>In the second part the task would be to use a prop in the component as initial value to pass\n<code>&lt;Counting initialCount=0</code>\nI find there are different ways. The best way is to setState to that initial value that is destructured in the function arguments:</p><pre><code>function Counting({ initialCount = 0 })\n</code></pre><p>Destructuring is necessary because initial name is an object so, if passing the argument just like (initialCount), the result will be a <!-- -->[Object object]<!-- -->.\nThe default value (= &#x27;&#x27;) is also necessary in case we don&#x27;t pass anything as a prop. In this case we don&#x27;t cause a crash because of undefined value.\nSo one way is to setState(initialCount) and value=count in the input.</p><p>Another possible way is to set the defaultValue of the input to the initialCount. This will have the same effect except that the state of the rendered text won&#x27;t be updated until something is typed. It&#x27;s possible to create a check to use the count (like a nested if but with ternary operator). However, it will make the code more difficult to read and follow in its flow.</p><h2 id=\"2---useeffect\"><a href=\"#2---useeffect\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>2 - useEffect</h2><ul><li><p>it&#x27;s called every render of the component, including the first and every time the state changes</p></li><li><p>to persist the state, call the localstorage methods inside useEffect <code>const [name, setName] = React.useState(window.localStorage.getItem(&#x27;name&#x27;) || initialName)</code></p></li><li><p>localStorage performance issue - slow</p></li><li><p>React’s useState hook allows you to pass a function instead of the actual value, and then it will only call that function to get the state value when the component is rendered the first time: <code>React.useState(() =&gt; someExpensiveComputation())</code> ... that&#x27;s the same as the callback on setState in class components</p></li><li><p>lazy initialization = not reading from localStorage every render\n--&gt; create a callback function: useEffect\n<code>const [name, setName] = React.useState(() =&gt; window.localStorage.getItem(&#x27;name&#x27;) || initialName)</code>\nIf we put a console inside the callback we cans see it&#x27;s called only on the first render</p></li><li><p>To be used only for bottleneck functions that require sync time</p></li><li><p>dependency array: second argument on useEffect which signals to React that your effect callback function should be called when (and only when) those dependencies change:</p></li></ul><pre><code>React.useEffect(() =&gt; {\n    window.localStorage.setItem(&#x27;count&#x27;, count)\n  }, [name])\n</code></pre><p>if other states apart fron name change setItem won&#x27;t be called\nIf left empty it&#x27;s like never use useEffect with any state with useEffect\nThe state in the dependency array is an object that is compared on the render with the previous state with object comparation. If it&#x27;s the same won&#x27;t run useEffect, otherwise yes.</p><p>Custom hooks: external function called inside the hook whose name starts with ”use”.\nIf we have different functions inside the compoenent method we can externilize those, even useEffect:</p><pre><code>function Greeting({ initialCount = 0 }) {\n  const [count, setCount] = React.useState(\n    () =&gt; window.localStorage.getItem(&#x27;count&#x27;) || initialCount,\n  )\n\n  React.useEffect(() =&gt; {\n    window.localStorage.setItem(&#x27;count&#x27;, count)\n  }, [count])\n\n  function handleChange(event) {\n    setCount(event.target.value)\n  }\n</code></pre><p>to --&gt;</p><pre><code>function useLocalStorageWithState() {\n  const [count, setCount] = React.useState(\n    () =&gt; window.localStorage.getItem(&#x27;count&#x27;) || initialCount,\n  )\n\n  React.useEffect(() =&gt; {\n    window.localStorage.setItem(&#x27;count&#x27;, count)\n  }, [count])\n\n  return [count, setCount];\n}\n\nfunction Greeting({ initialCount= 0 }) {\n  const [count, setCount] = useLocalStorageWithState()\n  function handleChange(event) {\n    setCount(event.target.value)\n  }\n</code></pre><p>Setting up a callback inside useState makes the setting of the state as lazy, as it compares the states and doesn&#x27;t change it if it&#x27;s the same.</p><p>Getting the error React Hook ... is called in function ... which is neither a React function component or custom React Hook function?\nIt&#x27;s because of a React convention, it just means that your function doesn&#x27;t start with use. Yes, that&#x27;s it! A custom hook must start with use!\nSo, instead of syncLocalStorageWithState, we call it useLocalStorageWithState.</p><p>useLocalStorageWithState should have the same use as the useState hook, so it can return an array like useState, and we can store in a same array. So we have created a customed useState hook that does other stuff as well.\nWe pass as well count and initialCount as parameters <code>useLocalStorageWithState(count, initialCount)</code> and then making useLocalStorageWithState more generic, receiving as arguments <code>key, defaultValue</code> , so the method can be reused freely and not stay chained to a count state. The same applies to the state. We can set <!-- -->[state, setState]<!-- --> and return the same.\nHaving two arguments means that also useEffect should have two in the dependency array.</p><ul><li>flexible localStorage hook. This was the most complex part of the workshop to think about. The solution is not so complicated, but to be honest I couldn&#x27;t manage until checking the video how to make this logic work (ok maybe it&#x27;s because I&#x27;m tired 😅)\nAnd the logic is the following:<ul><li>get the item from local storage</li><li>if present, JSON parse it and return the result</li><li>if not, return the default value</li></ul></li></ul><p>That&#x27;s for setting the state; for making the changes (useEffect), in this case for creating/editing the local storage, once the state changes we can just stringify whatever the state will be and store it.\nSerialize will be for stringify the JSON, while deserialize for parsing it.</p><p>In case as argument of useLocalStorageWithState, instead of a number, we&#x27;ll pass a function, it&#x27;s possible to create a check to return the results of another function.\n<code>const [name, setName] = useLocalStorageWithState(&#x27;name&#x27;, complexCounting() )</code> --&gt; pass a function as default value\n<code>return typeof defaultValue === &#x27;function&#x27; ? defaultValue() : defaultValue;</code> --&gt; return to useState the result of the method</p><p>Then it comes the complicated part. The case is what if somebody wants to pass another value to the &#x27;key&#x27;? Now it&#x27;s passed &#x27;count&#x27; as string, but maybe somebody will change it.\nThere&#x27;s no direct way to change the state of the key, so what is done is store the key into a var that won&#x27;t trigger the render, using useRef. Following that, in useEffect we can compare the old key with the new one.</p><p>According to the docs:</p><blockquote><p>useRef returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component.\nNote that useRef() is useful for more than the ref attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes.</p></blockquote><p>The difference with useState is then that useRef doesn&#x27;t trigger a rerender, so with this hook we can actually set the key without triggering the rerender. The purpose of this is clear in the useEffect.</p><pre><code>const prevKey = prevKeyRef.current;\n    if (prevKey !== key) {\n      window.localStorage.removeItem(prevKey)\n    }\n</code></pre><p>That means that usually we store in localStorage a value. But this value is in an object, and that object has a key. So for now it&#x27;s &#x27;count&#x27;. But if it will be &#x27;sum&#x27;, and we don&#x27;t remove the initial key, we&#x27;ll have two objects in localStorage. So if the new key and the old one, which is stored in the useRef var, is different, we will remove the obect in localStorage with the old key.</p><h2 id=\"3---lifting-and-colocating-state\"><a href=\"#3---lifting-and-colocating-state\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>3 - Lifting and Colocating state</h2><p>Lifting state is when you have state managed inside a component but a parent component needs it to render it or display it somewhere else.\nSo when it&#x27;s needed to lifting state, we take that state and find the least common parent between the two components. So the state is lifted from a lower branch of the family -or the tree- to a higher one.</p><p>Colocating state, instead, is to place the state management the furthest down the tree as possible where not shared by a parent component. A state correctly colocated helps React to not having to render the whole application for just, for example, an input change.\nIf a state is used only by a component up the tree, it&#x27;s probably possible to refactor it colocating the state in the sibling component that is managing it.</p><pre><code>  const [name, setName] = React.useState(&#x27;&#x27;)\n  const [animal, setAnimal] = React.useState(&#x27;&#x27;)\n  return (\n      &lt;Name name={name} onNameChange={event =&gt; setName(event.currentTarget.value)} /&gt;\n      &lt;FavoriteAnimal animal={animal} onAnimalChange={event =&gt; setAnimal(event.currentTarget.value)} /&gt;\n      &lt;Display animal={animal} /&gt;\n  )\n</code></pre><p>In the above case, for example, the animal state was lifted to the parent component as it&#x27;s used by the Display component as well. But the name state is not used, so it can be colocated to Name component only. This will result like this:</p><pre><code>function Name() {\n  const [name, setName] = React.useState(&#x27;&#x27;)\n\n  return (\n    &lt;div&gt;\n      &lt;label htmlFor=&quot;name&quot;&gt;Name: &lt;/label&gt;\n      &lt;input id=&quot;name&quot; value={name} onChange={event =&gt; setName(event.currentTarget.value)} /&gt;\n    &lt;/div&gt;\n  )\n}\n\nconst [animal, setAnimal] = React.useState(&#x27;&#x27;)\n  return (\n    &lt;form&gt;\n      &lt;Name /&gt;\n      &lt;FavoriteAnimal animal={animal} onAnimalChange={event =&gt; setAnimal(event.currentTarget.value)} /&gt;\n      &lt;Display animal={animal} /&gt;\n  )\n</code></pre><ul><li>set local storage is a side effect as it&#x27;s an async function, so it&#x27;s required to be inside useEffect</li></ul><h2 id=\"4---manipulating-the-dom-via-react\"><a href=\"#4---manipulating-the-dom-via-react\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>4 - Manipulating the DOM via React</h2><p>As there&#x27;s no direct access to the DOM via React, this can be done via Refs</p><pre><code>function MyDiv() {\n  const myDivRef = React.useRef()\n  React.useEffect(() =&gt; {\n    const myDiv = myDivRef.current\n    // myDiv is the div DOM node!\n    console.log(myDiv)\n    // DO some action\n    return // cancel events at the unmounting of the component (garbage collected)\n  }, [])\n  return &lt;div ref={myDivRef}&gt;hi&lt;/div&gt;\n}\n</code></pre><p>Once the component is mounted, useEffect will run and store into the myDiv const the current value of the DOM node of the div.\nIn this case we leave an empty dependency array as it doesn&#x27;t depend on the state of the app, so it happens once only.</p><h2 id=\"5---http-requests\"><a href=\"#5---http-requests\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>5 - HTTP requests</h2><p>One has to be careful in calling async functions inside useEffect, because it can&#x27;t be done directly as they&#x27;ll return promises instead of data or the results.\nIt has to be done via callback, either inside the useEffect, of externalizing it.</p><pre><code>React.useEffect(() =&gt; {\n  async function effect() {   // creating inside the callback the async method\n    const result = await doSomeAsyncThing() // call the async function\n  }\n  effect()  // calling the method as callback (so no promise will return, but the actual results)\n})\n</code></pre><p>The other way is creating the function outside useEffect and calling it inside as callback</p><pre><code>React.useEffect(() =&gt; {\n  doSomeAsyncThing().then(result =&gt; {\n  })\n})\n</code></pre>","scope":{}},"frontMatter":{"wordCount":1867,"readingTime":{"text":"10 min read","minutes":9.325,"time":559500,"words":1865},"slug":"learning-on-epic-react-hooks","fileName":"learning-on-epic-react-hooks.mdx","title":"Epic React. Hooks. What I'm learning.","date":"2020-11-06","template":"post","draft":true,"tags":["react","web development","epic react"],"summary":"A guide of what I'm learning on the Epic React workshopds by Kent Dodds. This is the second one: useState + useEffect"}},"prev":{"title":"What I learnt in my first six months as a working (self-taught) developer","date":"2021-07-06","template":"post","draft":false,"tags":["insights"],"summary":"The first six months of a developer are maybe the most challenging. This is what I learnt. My mistakes and accomplishments, to become a better dev","slug":"what-learnt-in-first-six-months-self-taught-developer"},"next":null},"__N_SSG":true}