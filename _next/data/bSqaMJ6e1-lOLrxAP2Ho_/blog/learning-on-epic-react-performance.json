{"pageProps":{"post":{"mdxSource":{"compiledSource":"\"use strict\";\n\nvar _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", {\n    \"id\": \"code-splitting\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#code-splitting\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"Code splitting\"), mdx(\"p\", null, \"Code splitting is a technique that allows code to be used only on need-basis, through lazy loading of that code. It shows like this in Javascript:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import('/some-module.js').then(\\n  module => {\\n    // do stuff with the module's exports\\n  },\\n  error => {\\n    // there was some error loading the module...\\n  },\\n)\\n\")), mdx(\"p\", null, \"In React it's taken a step further using the React.Suspense component for the fallback meanwhile the user wait for its loading. The import is done by React.lazy. The component to be imported must have a default export.\"), mdx(\"p\", null, \"That's how it's working. Having this code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import HeavyComponent from '../heavycomponent'\\n...\\n<div>\\n  <HeavyComponent />\\n</div>\\n\")), mdx(\"p\", null, \"will load the component right away in the application. Let's transform it to use it as code splitted.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const HeavyComponent = React.lazy(() => import('../heavycomponent'))\\n...\\n<div>\\n  <React.Suspense fallback={<div>loading...</div>}>\\n    <HeavyComponent />\\n  </React.Suspense>\\n</div>\\n\")), mdx(\"p\", null, \"with the first code and an artificial slow 3G connection, the page was loading in 14 seconds. With lazy loading, between 6 and 8 seconds. A 50% gain.\"), mdx(\"p\", null, \"In addition to that, we can start loading the heavy component before the user actually wants to see it. We can add some listener like mouseOver or mouseEnter, or onFocus, to start lazily loading the component without showing it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const loadHeavyComponent = () => import('../heavycomponent')\\n\\n<div>\\n  <label of any kind\\n    onMouseEnter={loadHeavyComponent}\\n    onFocus={loadHeavyComponent}\\n  >\\n  <input of any kind>\\n</div>\\n\\n<div>\\n  <React.Suspense fallback={<div>loading...</div>}>\\n    <HeavyComponent />\\n  </React.Suspense>\\n</div>\\n\")), mdx(\"p\", null, \"There is a way as well to pre-fetch the chunks by webpack, once the main component has loaded: webpack magic comments.\"), mdx(\"p\", null, \"One that is presented is just for this, using the code above:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const loadHeavyComponent = () => import(/* webpackPrefetch: true */ '../heavycomponent')\\n\")), mdx(\"p\", null, \"This will appear in the browser DOM, through Webpack, as\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"<link rel=\\\"prefetch\\\" as=\\\"script\\\" href=\\\"/static/js/1.f2976096.chunk.js\\\">\\n<link rel=\\\"prefetch\\\" as=\\\"script\\\" href=\\\"/static/js/2.a7113cc3.chunk.js\\\">\\n\")), mdx(\"p\", null, \"Another magic comment is webpackChunkName, which can be used for both placing common modules in the same chunk, and giving the chunk a name.\"), mdx(\"p\", null, \"More info could be found here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://webpack.js.org/api/module-methods/#magic-comments\"\n  }, \"https://webpack.js.org/api/module-methods/#magic-comments\")), mdx(\"p\", null, \"Note: suspension is good to be put outside of conditions as its components will be loaded when the HeavyComponent will be showing up, if inside, creating a problem with the new Concurrency methods.\"), mdx(\"p\", null, \"To check the suspension in the devtools, there's this little icon that anytime can be clicked and the component will go into the fallback.\"), mdx(\"p\", null, \"An interesting tool about checking performance is the Coverage devtool.\\nIf we check the initial version of the code (without lazy loading) and the final version (without prefetch), the final has not only a lot fewer chunk files and less Kbs loaded, but also the final version has less Kb ran comparing to the initial one.\\nIt's like 20% less heavy and around 30% less code run.\"), mdx(\"p\", null, \"In the coverage tool, in Usage Visualization, we can check how much of code is not used on the run. Even in the final version is more than 50%. This information can be used to check what to do more as code splitting. Clicking on it will show the file on the source tab, with lines that are run and lines that aren't.\"), mdx(\"h3\", {\n    \"id\": \"usememo\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#usememo\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"useMemo\"), mdx(\"p\", null, \"React useMemo is well known in the React world, but as I could see in some professional projects I worked on, sometimes it's abused in its use. \"), mdx(\"p\", null, \"One good thing about this workshop is showing how to use the Performance devtool, and analyzing the difference in a heavy-calculation method before the use of useMemo and after.\\nThe recording of the performance is a simple operation, but one can get lost in the data.\\nWhere there are performance bottlenecks, a rose-red line will appear on top of the graph. Selecting that part, and using the Main section of the graph below, it's possible to encounter down below the method/methods and their children that are slowing down the application. And also what kind of activity the method is doing taking long time.\"), mdx(\"p\", null, \"The most interesting topic on this part of the workshop is the part building a web worker. As we have our method that needs to do an expensive calculation, even crunching the best optimization is creating anyway a little bottleneck there.\\nAs JavaScript is single threaded, a solution could consist in creating a web worker, because it will work as a separate thread. In that case, the calculation can be done in the worker and sent back to the application once it's done, not blocking the rest of it.\"), mdx(\"p\", null, \"In order to do so, we can load that component with the calculation via the worker. Using webpack, there's a shortcut: adding 'workerize!' in the string of the import will automatically create it as a method, which we can then export.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"import makeFilterCitiesWorker from 'workerize!./filter-cities'\\n\\nconst {getItems} = makeFilterCitiesWorker()\\n\\nexport {getItems}\\n\")), mdx(\"p\", null, \"After that, the only difference in its implementation is that the data is async and not sync anymore, so there's some work to do in the application to make it so.\\nWith this specification,  even in developer mode, the click method resolved in 20 ms instead of the previous 50ms in production mode.\"), mdx(\"h3\", {\n    \"id\": \"react-memo\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#react-memo\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"React memo\"), mdx(\"p\", null, \"There are cases in which some components are re-rendered although it's not necessary just because they're dependent on the parent component, so whenever this one re-renders, also the child component does unnecessarily, as no DOM updates were needed.\"), mdx(\"p\", null, \"This can be checked in the Profiler section of the Devtools, with the option \\\" Record why each component rendered while profiling.\\\" checked (in settings). Once profiling, we can make our actions on the page and once stopped recording, we can see what/when/why components rendered. The suspicious ones are the ones rerendered because the parent component rendered again. These have to be double-checked in case there is a useless rerender.\"), mdx(\"p\", null, \"In order to use it, we can have the normal method and then reassign the method with the memoization.\\nSupposing that we have a method \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function ListCities() {\\n  ...\\n}\\n\")), mdx(\"p\", null, \"then we can memoize it just like this.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"ListCities = React.memo(ListCities)\\n\")), mdx(\"p\", null, \"At this moment we reduced the render to only the component that is changing props or state. However there could be the case in which, under that component, there's some method that is triggering the re-rendering again for everything.\\nWe can avoid that using the condition of React memo, in the second argument as a callback returning a boolean. If it's false, it will rerender; if true, it won't.\"), mdx(\"p\", null, \"We take from the callback two arguments, previous and next props (like in many React hooks), and we can check whether the prevProp is the same or it has changed comparing to the next one.\\nWe can give multiple conditions, one for each prop, with multiple if statements.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"ListCities = React.memo(ListCities, (prevProps, nextProps) => {\\n\\n  if (prevProps.getCitiesProps !== nextProps.getCitiesProps) return false\\n  if (prevProps.getCitiesProps2 !== nextProps.getCitiesProps2) return false\\n  if (prevProps.index !== nextProps.index) return false\\n \\n  return true\\n})\\n\")), mdx(\"p\", null, \"Eventually the best way to do it, if we're going to use calculation that updates specific props in the component, is to move those props a little higher in the tree. So, instead of having ListCities with the calculations, we can move them in the parent component and passed those down below as props or primitive values. This way, when memo is called, it'll do an automatic comparison and update only what is necessary to update. And then call the component with memo without other options:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"ListCities = React.memo(ListCities)\\n\")), mdx(\"h3\", {\n    \"id\": \"react-virtual\"\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#react-virtual\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }, mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"icon icon-link\"\n  })), \"React Virtual\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h3 id=\"code-splitting\"><a href=\"#code-splitting\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Code splitting</h3><p>Code splitting is a technique that allows code to be used only on need-basis, through lazy loading of that code. It shows like this in Javascript:</p><pre><code>import(&#x27;/some-module.js&#x27;).then(\n  module =&gt; {\n    // do stuff with the module&#x27;s exports\n  },\n  error =&gt; {\n    // there was some error loading the module...\n  },\n)\n</code></pre><p>In React it&#x27;s taken a step further using the React.Suspense component for the fallback meanwhile the user wait for its loading. The import is done by React.lazy. The component to be imported must have a default export.</p><p>That&#x27;s how it&#x27;s working. Having this code:</p><pre><code>import HeavyComponent from &#x27;../heavycomponent&#x27;\n...\n&lt;div&gt;\n  &lt;HeavyComponent /&gt;\n&lt;/div&gt;\n</code></pre><p>will load the component right away in the application. Let&#x27;s transform it to use it as code splitted.</p><pre><code>const HeavyComponent = React.lazy(() =&gt; import(&#x27;../heavycomponent&#x27;))\n...\n&lt;div&gt;\n  &lt;React.Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt;\n    &lt;HeavyComponent /&gt;\n  &lt;/React.Suspense&gt;\n&lt;/div&gt;\n</code></pre><p>with the first code and an artificial slow 3G connection, the page was loading in 14 seconds. With lazy loading, between 6 and 8 seconds. A 50% gain.</p><p>In addition to that, we can start loading the heavy component before the user actually wants to see it. We can add some listener like mouseOver or mouseEnter, or onFocus, to start lazily loading the component without showing it.</p><pre><code>const loadHeavyComponent = () =&gt; import(&#x27;../heavycomponent&#x27;)\n\n&lt;div&gt;\n  &lt;label of any kind\n    onMouseEnter={loadHeavyComponent}\n    onFocus={loadHeavyComponent}\n  &gt;\n  &lt;input of any kind&gt;\n&lt;/div&gt;\n\n&lt;div&gt;\n  &lt;React.Suspense fallback={&lt;div&gt;loading...&lt;/div&gt;}&gt;\n    &lt;HeavyComponent /&gt;\n  &lt;/React.Suspense&gt;\n&lt;/div&gt;\n</code></pre><p>There is a way as well to pre-fetch the chunks by webpack, once the main component has loaded: webpack magic comments.</p><p>One that is presented is just for this, using the code above:</p><pre><code>const loadHeavyComponent = () =&gt; import(/* webpackPrefetch: true */ &#x27;../heavycomponent&#x27;)\n</code></pre><p>This will appear in the browser DOM, through Webpack, as</p><pre><code>&lt;link rel=&quot;prefetch&quot; as=&quot;script&quot; href=&quot;/static/js/1.f2976096.chunk.js&quot;&gt;\n&lt;link rel=&quot;prefetch&quot; as=&quot;script&quot; href=&quot;/static/js/2.a7113cc3.chunk.js&quot;&gt;\n</code></pre><p>Another magic comment is webpackChunkName, which can be used for both placing common modules in the same chunk, and giving the chunk a name.</p><p>More info could be found here: <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://webpack.js.org/api/module-methods/#magic-comments\">https://webpack.js.org/api/module-methods/#magic-comments</a></p><p>Note: suspension is good to be put outside of conditions as its components will be loaded when the HeavyComponent will be showing up, if inside, creating a problem with the new Concurrency methods.</p><p>To check the suspension in the devtools, there&#x27;s this little icon that anytime can be clicked and the component will go into the fallback.</p><p>An interesting tool about checking performance is the Coverage devtool.\nIf we check the initial version of the code (without lazy loading) and the final version (without prefetch), the final has not only a lot fewer chunk files and less Kbs loaded, but also the final version has less Kb ran comparing to the initial one.\nIt&#x27;s like 20% less heavy and around 30% less code run.</p><p>In the coverage tool, in Usage Visualization, we can check how much of code is not used on the run. Even in the final version is more than 50%. This information can be used to check what to do more as code splitting. Clicking on it will show the file on the source tab, with lines that are run and lines that aren&#x27;t.</p><h3 id=\"usememo\"><a href=\"#usememo\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>useMemo</h3><p>React useMemo is well known in the React world, but as I could see in some professional projects I worked on, sometimes it&#x27;s abused in its use. </p><p>One good thing about this workshop is showing how to use the Performance devtool, and analyzing the difference in a heavy-calculation method before the use of useMemo and after.\nThe recording of the performance is a simple operation, but one can get lost in the data.\nWhere there are performance bottlenecks, a rose-red line will appear on top of the graph. Selecting that part, and using the Main section of the graph below, it&#x27;s possible to encounter down below the method/methods and their children that are slowing down the application. And also what kind of activity the method is doing taking long time.</p><p>The most interesting topic on this part of the workshop is the part building a web worker. As we have our method that needs to do an expensive calculation, even crunching the best optimization is creating anyway a little bottleneck there.\nAs JavaScript is single threaded, a solution could consist in creating a web worker, because it will work as a separate thread. In that case, the calculation can be done in the worker and sent back to the application once it&#x27;s done, not blocking the rest of it.</p><p>In order to do so, we can load that component with the calculation via the worker. Using webpack, there&#x27;s a shortcut: adding &#x27;workerize!&#x27; in the string of the import will automatically create it as a method, which we can then export.</p><pre><code>import makeFilterCitiesWorker from &#x27;workerize!./filter-cities&#x27;\n\nconst {getItems} = makeFilterCitiesWorker()\n\nexport {getItems}\n</code></pre><p>After that, the only difference in its implementation is that the data is async and not sync anymore, so there&#x27;s some work to do in the application to make it so.\nWith this specification,  even in developer mode, the click method resolved in 20 ms instead of the previous 50ms in production mode.</p><h3 id=\"react-memo\"><a href=\"#react-memo\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>React memo</h3><p>There are cases in which some components are re-rendered although it&#x27;s not necessary just because they&#x27;re dependent on the parent component, so whenever this one re-renders, also the child component does unnecessarily, as no DOM updates were needed.</p><p>This can be checked in the Profiler section of the Devtools, with the option &quot; Record why each component rendered while profiling.&quot; checked (in settings). Once profiling, we can make our actions on the page and once stopped recording, we can see what/when/why components rendered. The suspicious ones are the ones rerendered because the parent component rendered again. These have to be double-checked in case there is a useless rerender.</p><p>In order to use it, we can have the normal method and then reassign the method with the memoization.\nSupposing that we have a method </p><pre><code>function ListCities() {\n  ...\n}\n</code></pre><p>then we can memoize it just like this.</p><pre><code>ListCities = React.memo(ListCities)\n</code></pre><p>At this moment we reduced the render to only the component that is changing props or state. However there could be the case in which, under that component, there&#x27;s some method that is triggering the re-rendering again for everything.\nWe can avoid that using the condition of React memo, in the second argument as a callback returning a boolean. If it&#x27;s false, it will rerender; if true, it won&#x27;t.</p><p>We take from the callback two arguments, previous and next props (like in many React hooks), and we can check whether the prevProp is the same or it has changed comparing to the next one.\nWe can give multiple conditions, one for each prop, with multiple if statements.</p><pre><code>ListCities = React.memo(ListCities, (prevProps, nextProps) =&gt; {\n\n  if (prevProps.getCitiesProps !== nextProps.getCitiesProps) return false\n  if (prevProps.getCitiesProps2 !== nextProps.getCitiesProps2) return false\n  if (prevProps.index !== nextProps.index) return false\n \n  return true\n})\n</code></pre><p>Eventually the best way to do it, if we&#x27;re going to use calculation that updates specific props in the component, is to move those props a little higher in the tree. So, instead of having ListCities with the calculations, we can move them in the parent component and passed those down below as props or primitive values. This way, when memo is called, it&#x27;ll do an automatic comparison and update only what is necessary to update. And then call the component with memo without other options:</p><pre><code>ListCities = React.memo(ListCities)\n</code></pre><h3 id=\"react-virtual\"><a href=\"#react-virtual\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>React Virtual</h3>","scope":{}},"frontMatter":{"wordCount":1249,"readingTime":{"text":"7 min read","minutes":6.235,"time":374100,"words":1247},"slug":"learning-on-epic-react-performance","fileName":"learning-on-epic-react-performance.md","title":"Epic React. Performance.","date":"2022-03-01","draft":true,"tags":["react","web development","epic react"],"summary":"test"}},"prev":{"title":"How I passed from Junior to Intermediate developer in one year","date":"2021-12-15","draft":false,"tags":["insights"],"summary":"Learning from going above junior is not easy. This is why I think I did it and what I could learn in this passage","slug":"how-passed-from-junior-to-intermediate-dev-one-year"},"next":null},"__N_SSG":true}