{"pageProps":{"post":{"mdxSource":"var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var l=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var r=n=>s(n,\"__esModule\",{value:!0});var m=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),f=(n,e)=>{r(n);for(var a in e)s(n,a,{get:e[a],enumerable:!0})},w=(n,e,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!g.call(n,o)&&o!==\"default\"&&s(n,o,{get:()=>e[o],enumerable:!(a=l(e,o))||a.enumerable});return n},y=n=>w(r(s(n!=null?d(u(n)):{},\"default\",n&&n.__esModule&&\"default\"in n?{get:()=>n.default,enumerable:!0}:{value:n,enumerable:!0})),n);var h=m((I,i)=>{i.exports=_jsx_runtime});var v={};f(v,{default:()=>k,frontmatter:()=>b});var t=y(h()),b={title:\"Finding a bug after writing a test, an example\",date:\"2022-11-30\",draft:!1,tags:[\"web development\",\"react\",\"testing\"],summary:\"I wrote a test and found a small bug. Even in React writing tests is important\"};function c(n){let e=Object.assign({p:\"p\",pre:\"pre\",code:\"code\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"In almost every Sprint, at work, I try to reserve some space for solving tech debt and doing some refactoring. A part of resolving this debt is making integration tests. And sometimes it happens that those tests find some unknown bug. That's what happened a few days ago. As usual, the names of the methods and variables are just an example.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The page I was writing the tests on is a simple one. Some text, three buttons, and nothing more. Yet, it has some hooks as well, defining the logic of those buttons (opening another URL, submitting the form, etc).\"}),`\n`,(0,t.jsx)(e.p,{children:\"I started writing the tests in the usual way, using React Testing Library. Checking the rendering and the behavior of the page by clicking on the different buttons. When I was writing the test for one of the three buttons, however, it forced me to let me think: is this button always visible? Why?\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`{showButton && (\n   <Button onClick={onApplyClick}>\n      DO THING\n   </Button>\n )}\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"I checked the hooks and found out that it would render only when another property was true, or present. So why it was always there?\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`  showButton: !!secondaryProp,\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"I followed the source of that property and I came across the point where its data was fetched from the (easy-peasy) store, and then it was set as an initial value of 0, instead of being undefined.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const initialState: IState = {\n  ...\n  secondaryProp: 0,\n`})}),`\n`,(0,t.jsx)(e.p,{children:'The type of that property was just \"number\", instead of \"number?\". So it was always true.'}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`export interface IState {\n  secondaryProp: number\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"To fix it, I changed the type and set the initial values as undefined.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Re-checking that property I saw that another value was dependent on it being present or not. So in another hook, I had to redefine the behavior in case the prop was falsy.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const newUrl = secondaryProp && \\`\\${FETCHED_URL}/prop=\\${secondaryProp}\\`\n\nconst onClick = () => {\n    if (!newUrl) {\n      return\n    }\n\n    window.open(newUrl)\n  }\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"So that's an interesting case of how making tests helps you reflect on what the behavior, and the logic of the methods and components, should be.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Thank you for reading! Let's connect on \",(0,t.jsx)(e.a,{href:\"https://twitter.com/AlexBuaiscia\",children:\"Twitter\"}),\" or \",(0,t.jsx)(e.a,{href:\"@alex_@uiuxdev.social\",children:\"Mastodon\"}),\"!\"]})]})}function x(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(c,n)})):c(n)}var k=x;return v;})();\n;return Component;","toc":[],"frontMatter":{"readingTime":{"text":"3 min read","minutes":2.085,"time":125100,"words":417},"slug":"tips/finding-bug-writing-tests-example","fileName":"tips/finding-bug-writing-tests-example.md","title":"Finding a bug after writing a test, an example","date":"2022-11-30T00:00:00.000Z","draft":false,"tags":["web development","react","testing"],"summary":"I wrote a test and found a small bug. Even in React writing tests is important"}},"authorDetails":[{"readingTime":{"text":"1 min read","minutes":0.835,"time":50100,"words":167},"slug":["default"],"fileName":"default.md","name":"Alex Buaiscia","avatar":"/static/images/avatar.png","occupation":"Full-stack Software Developer","company":"Moravio","twitter":"https://twitter.com/AlexBuaiscia","linkedin":"https://www.linkedin.com/in/alex-buaiscia/","github":"https://github.com/buaiscia","date":null}],"prev":{"title":"Make a reusable test with React Testing Library","date":"2022-11-22T00:00:00.000Z","draft":false,"tags":["web development","react","react testing library","testing"],"summary":"Abstract methods to be reused by different tests","slug":"tips/make-reusable-test-react-testing-library"},"next":{"title":"Reduce your Jest tests running time (especially on hooks!) with the maxWorkers option","date":"2022-12-08T00:00:00.000Z","draft":false,"tags":["web development","jest","testing"],"summary":"How tweaking the maxWorkers option can increase tests efficiency","slug":"tips/reduce-jest-tests-running-time-maxworkers"}},"__N_SSG":true}