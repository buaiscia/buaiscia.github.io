{"pageProps":{"post":{"mdxSource":"var Component=(()=>{var c=Object.create;var i=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var r=a=>i(a,\"__esModule\",{value:!0});var f=(a,t)=>()=>(t||a((t={exports:{}}).exports,t),t.exports),w=(a,t)=>{r(a);for(var s in t)i(a,s,{get:t[s],enumerable:!0})},g=(a,t,s)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let n of h(t))!m.call(a,n)&&n!==\"default\"&&i(a,n,{get:()=>t[n],enumerable:!(s=d(t,n))||s.enumerable});return a},u=a=>g(r(i(a!=null?c(p(a)):{},\"default\",a&&a.__esModule&&\"default\"in a?{get:()=>a.default,enumerable:!0}:{value:a,enumerable:!0})),a);var o=f((j,l)=>{l.exports=_jsx_runtime});var y={};w(y,{default:()=>b,frontmatter:()=>N});var e=u(o()),N={title:\"Mock an Axios call with a JSON file.\",date:\"2020-11-13\",draft:!1,tags:[\"nodejs\",\"web development\",\"api\",\"tips\"],summary:\"How to avoid test calling a third party API with Axios using a mock JSON file\"};function x(a={}){let{wrapper:t}=a.components||{};return t?(0,e.jsx)(t,Object.assign({},a,{children:(0,e.jsx)(s,{})})):s();function s(){let n=Object.assign({p:\"p\",h2:\"h2\",a:\"a\",span:\"span\",pre:\"pre\",code:\"code\"},a.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.p,{children:\"Every now and then, working on the backend of a project, we have to deal with calling third party APIs via fetch or Axios. It's perfectly doable also during testing if the other API has a development or stage environment to experiment with. But there are some cases in which this isn't happening, unfortunately; or there are other cases in which stage/staging is not available (because, for example, it is busy with another branch of the project). Or, most commonly, we don't want to make too many calls (they could be billable). After all, tests are made for this.\"}),(0,e.jsxs)(n.h2,{id:\"mocking-on-the-way-to-help\",children:[(0,e.jsx)(n.a,{href:\"#mocking-on-the-way-to-help\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Mocking on the way to help!\"]}),(0,e.jsx)(n.p,{children:\"We know mocking by the testing libraries, like Jest. They are used, for example, for mocking functions and testing the returned/resolved/rejected values, among many other ways to implement them. But what about Axios? We are in that stage of development that is happening before creating the tests (not TDD, conceded), and we don't know the side effects of updating something or even how the response will look like.\"}),(0,e.jsx)(n.p,{children:\"What we have is some good documentation to implement a feature and that's it. So how to mock the Axios call? Axios is returning an object as response. Unfortunately, we can't pass a JSON file directly as request from Axios because the service makes only http requests, hence it thinks we're passing a url string.\"}),(0,e.jsx)(n.p,{children:\"Let's show it as an example in NodeJS with Restify as framework:\"}),(0,e.jsx)(n.p,{children:\"Before:\"}),(0,e.jsx)(n.pre,{children:(0,e.jsxs)(n.code,{className:\"code-highlight\",children:[(0,e.jsx)(n.span,{className:\"code-line\",children:`public getAll = async (req, res, next) => {\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`        try {\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`             const url = 'http://url';\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`             const response = await axios.get(url);\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`             res.send(response.data)\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`        } catch (err) {\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`            next(new InternalError(errorMsg));\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`        }\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`        next();\n`})]})}),(0,e.jsx)(n.p,{children:\"After (wrong):\"}),(0,e.jsx)(n.pre,{children:(0,e.jsxs)(n.code,{className:\"code-highlight\",children:[(0,e.jsx)(n.span,{className:\"code-line\",children:`public getAll = async (req, res, next) => {\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`        try {\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`             const file = './mockFile.json';\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`             const response = await axios.get(file);\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`             res.send(response)\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`        } catch (err) {\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`            next(new InternalError(errorMsg));\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`        }\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`        next();\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`// send undefined\n`})]})}),(0,e.jsx)(n.p,{children:\"This will throw an exception as response will be undefined (Axios does the request to a string).\"}),(0,e.jsxs)(n.h2,{id:\"parsing-and-sending-a-json\",children:[(0,e.jsx)(n.a,{href:\"#parsing-and-sending-a-json\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Parsing and sending a JSON\"]}),(0,e.jsxs)(n.p,{children:[\"The way to proceed, then, is to override Axios and return the JSON object. However, there's a catch. If we just send the file, like this: \",(0,e.jsx)(n.code,{children:\"res.send(file)\"}),\" or even if we prepare it with the correct, relative path, like this: \",(0,e.jsx)(n.code,{children:\"const paths = path.normalize(__dirname + '/mockFile.json');\"}),\" again it won't be read. It will be undefined because a file is, well, a part of the file system. That gives the answer to this problem: we have to use the in-built Node module 'fs', then parse it and finally send it. Here's how:\"]}),(0,e.jsx)(n.pre,{children:(0,e.jsxs)(n.code,{className:\"code-highlight\",children:[(0,e.jsx)(n.span,{className:\"code-line\",children:`import {readFile } from \"fs\";\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`public getAll = (req, res, next) => {\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`        try {\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`            readFile(__dirname + '/mockFile.json', 'utf8', function (err, data) {\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`                if (err) throw err;\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`                data = JSON.parse(data);\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`                res.send(data);\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`                next();\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`            });\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`        } catch (err) {\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`            next(new InternalError(errorMsg));\n`}),(0,e.jsx)(n.span,{className:\"code-line\",children:`        }\n`})]})}),(0,e.jsx)(n.p,{children:\"If there will be an error, it will be thrown and caught by the catch method. The readFile method of fs in this case has three arguments: the path or the source to read, the encoding (optional, rarely will be different than utf8), and a callback function. Data will contain, as an object as a matter of fact, the JSON file. We will reassign to data the parsed object and finally we can send it to the next method to use it.\"}),(0,e.jsx)(n.p,{children:\"That's it! Now you can mock any kind of response and use it directly in the code to test it!\"}),(0,e.jsxs)(n.p,{children:[\"Thank you for reading and let's connect on \",(0,e.jsx)(n.a,{href:\"https://twitter.com/AlexBuaiscia\",children:\"Twitter\"}),\"!\"]})]})}}var b=x;return y;})();\n;return Component;","toc":[{"value":"Mocking on the way to help!","url":"#mocking-on-the-way-to-help","depth":2},{"value":"Parsing and sending a JSON","url":"#parsing-and-sending-a-json","depth":2}],"frontMatter":{"readingTime":{"text":"4 min read","minutes":3.185,"time":191100,"words":637},"slug":"tips/sending-mock-json-response-axios","fileName":"tips/sending-mock-json-response-axios.md","title":"Mock an Axios call with a JSON file.","date":"2020-11-13T00:00:00.000Z","draft":false,"tags":["nodejs","web development","api","tips"],"summary":"How to avoid test calling a third party API with Axios using a mock JSON file"}},"authorDetails":[{"readingTime":{"text":"1 min read","minutes":0.94,"time":56400,"words":188},"slug":["default"],"fileName":"default.md","name":"Alex Buaiscia","avatar":"/static/images/avatar.png","occupation":"Full-stack Software Developer","company":"Moravio","twitter":"https://twitter.com/AlexBuaiscia","linkedin":"https://www.linkedin.com/in/alex-buaiscia/","github":"https://github.com/buaiscia","date":null}],"prev":{"title":"Epic React. Fundamentals. What I'm learning.","date":"2020-10-30T00:00:00.000Z","draft":false,"tags":["react","web development","epic react"],"summary":"A guide of what I'm learning on the Epic React workshops by Kent Dodds. This is the first one: fundamentals","slug":"epic-react/learning-on-epic-react-fundamentals"},"next":{"title":"How I transitioned from humanistic jobs to tech and development and why it is possible to start from the basics.","date":"2020-12-02T00:00:00.000Z","draft":false,"tags":["insights","career"],"summary":"Transitioning from literature and languages to tech was not easy. Making a career from basic roles to developer is possible, and even better sometimes.","slug":"career/how-transitioned-from-humanistic-to-tech-and-helped"}},"__N_SSG":true}