{"pageProps":{"post":{"mdxSource":"var Component=(()=>{var l=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,d=Object.prototype.hasOwnProperty;var c=a=>o(a,\"__esModule\",{value:!0});var u=(a,t)=>()=>(t||a((t={exports:{}}).exports,t),t.exports),k=(a,t)=>{c(a);for(var s in t)o(a,s,{get:t[s],enumerable:!0})},g=(a,t,s)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let n of h(t))!d.call(a,n)&&n!==\"default\"&&o(a,n,{get:()=>t[n],enumerable:!(s=p(t,n))||s.enumerable});return a},N=a=>g(c(o(a!=null?l(m(a)):{},\"default\",a&&a.__esModule&&\"default\"in a?{get:()=>a.default,enumerable:!0}:{value:a,enumerable:!0})),a);var i=u((j,r)=>{r.exports=_jsx_runtime});var b={};k(b,{default:()=>f,frontmatter:()=>w});var e=N(i()),w={title:\"Memoize a React component\",date:\"2022-07-27\",draft:!1,tags:[\"web development\",\"react\",\"tips\"],summary:\"Using React.memo to memoize a React component\"};function y(a={}){let{wrapper:t}=a.components||{};return t?(0,e.jsx)(t,Object.assign({},a,{children:(0,e.jsx)(s,{})})):s();function s(){let n=Object.assign({p:\"p\",pre:\"pre\",code:\"code\",span:\"span\",a:\"a\"},a.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.p,{children:\"Memoization is a feature in React. The library compares (in a shallow way) two versions of an object and, if they are the same, does not re-render (or recompile) it, creating an optimization in performance and memory.\"}),(0,e.jsx)(n.p,{children:\"The React.memo higher order component (to notice, not useMemo) used on a component is very easy to implement, but it's not always efficient or necessary. As everything about memoization in React, we shouldn't memoize everything but just the objects that are heavy, big, or re-renders very often.\"}),(0,e.jsx)(n.p,{children:\"So in my job it happened an interesting case. I had quite a big parent component that is wrapping inside smaller children components. I'll just change the type of subjects and component name, but the example I'm giving is the same I have.\"}),(0,e.jsx)(n.p,{children:\"How do we memoize a component?\"}),(0,e.jsx)(n.p,{children:\"Supposing we have:\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsx)(n.code,{className:\"language-js code-highlight\",children:(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token keyword\",children:\"const\"}),\" \",(0,e.jsx)(n.span,{className:\"token function function-variable\",children:(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"BigComponent\"})}),\" \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"=\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsxs)(n.span,{className:\"token parameter\",children:[(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),(0,e.jsx)(n.span,{className:\"token operator spread\",children:\"...\"}),\"lots \",(0,e.jsx)(n.span,{className:\"token keyword\",children:\"of\"}),\" props\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"})]}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator arrow\",children:\"=>\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),(0,e.jsx)(n.span,{className:\"token operator spread\",children:\"...\"}),\"lots \",(0,e.jsx)(n.span,{className:\"token keyword\",children:\"of\"}),\" stuff done\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"}),`\n`]})})}),(0,e.jsx)(n.p,{children:\"then we just put memo on the export\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsx)(n.code,{className:\"language-js code-highlight\",children:(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token keyword module\",children:\"export\"}),\" \",(0,e.jsx)(n.span,{className:\"token keyword module\",children:\"default\"}),\" \",(0,e.jsx)(n.span,{className:\"token function\",children:\"memo\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"BigComponent\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),`\n`]})})}),(0,e.jsx)(n.p,{children:\"Is it enough? Sometimes yes. But the more interesting part is another. How does React knows what to compare? It takes a previous version, and a next version (the one we're updating with new props). In the same way, memo could use those two version as callback arguments. They can be checked to make a quicker comparison, speeding up even more the memoization process.\"}),(0,e.jsx)(n.p,{children:\"Supposing that our BigComponent is mostly managing a school student card, and we have the children components showing according to the student. Then we'll have BigComponent supposedly changing when the id of the student change (supposing that is mapped from a parent component).\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsx)(n.code,{className:\"language-js code-highlight\",children:(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token keyword\",children:\"const\"}),\" \",(0,e.jsx)(n.span,{className:\"token function function-variable\",children:(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"BigComponent\"})}),\" \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"=\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsxs)(n.span,{className:\"token parameter\",children:[(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),\"student\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator spread\",children:\"...\"}),\"other props\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"})]}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator arrow\",children:\"=>\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),(0,e.jsx)(n.span,{className:\"token operator spread\",children:\"...\"}),\"lots \",(0,e.jsx)(n.span,{className:\"token keyword\",children:\"of\"}),\" stuff done\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"}),`\n`]})})}),(0,e.jsx)(n.p,{children:\"We can now memoize the component comparing the IDs of the student. We can think of the IDs as the keys of the object. If they're the same, the component will remain the same, otherwise it will re-render.\"}),(0,e.jsx)(n.p,{children:\"But as you can see, I've done it slightly differently!\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsx)(n.code,{className:\"language-js code-highlight\",children:(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token keyword module\",children:\"export\"}),\" \",(0,e.jsx)(n.span,{className:\"token keyword module\",children:\"default\"}),\" \",(0,e.jsx)(n.span,{className:\"token function\",children:\"memo\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"BigComponent\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsxs)(n.span,{className:\"token parameter\",children:[\"prev\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),\" next\"]}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator arrow\",children:\"=>\"}),\" prev\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(n.span,{className:\"token property-access\",children:\"student\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(n.span,{className:\"token property-access\",children:\"id\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"!==\"}),\" next\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(n.span,{className:\"token property-access\",children:\"student\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(n.span,{className:\"token property-access\",children:\"id\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),`\n`]})})}),(0,e.jsx)(n.p,{children:\"This above will say: if the previous ID is different comparing to the next one, return true. The problem here is that we're getting the props and we use them on a child component, so if the IDs are the same (===) it won't do anything (won't open the card).\"}),(0,e.jsx)(n.p,{children:\"In my case, it checks that the IDs are different, and don't do anything. But if they're the same, it'll allow the rerender. It's similar to how ShouldComponentUpdate was working, as we're giving the condition on when to rerender.\"}),(0,e.jsx)(n.p,{children:\"So, to sum up, we're memoizing (not rerendering) this component the opposite way only when the IDs (keys) change. That means that when we open a student card it will rerender. But when we add more students, or we use other student cards, they won't rerender in the page, and we will be getting a performance improvement.\"}),(0,e.jsxs)(n.p,{children:[\"Thank you for reading and let's connect on \",(0,e.jsx)(n.a,{href:\"https://twitter.com/AlexBuaiscia\",children:\"Twitter\"}),\"!\"]})]})}}var f=y;return b;})();\n;return Component;","toc":[],"frontMatter":{"readingTime":{"text":"3 min read","minutes":2.97,"time":178200,"words":594},"slug":"tips/memoize-react-component","fileName":"tips/memoize-react-component.md","title":"Memoize a React component","date":"2022-07-27T00:00:00.000Z","draft":false,"tags":["web development","react","tips"],"summary":"Using React.memo to memoize a React component"}},"authorDetails":[{"readingTime":{"text":"1 min read","minutes":0.94,"time":56400,"words":188},"slug":["default"],"fileName":"default.md","name":"Alex Buaiscia","avatar":"/static/images/avatar.png","occupation":"Full-stack Software Developer","company":"Moravio","twitter":"https://twitter.com/AlexBuaiscia","linkedin":"https://www.linkedin.com/in/alex-buaiscia/","github":"https://github.com/buaiscia","date":null}],"prev":{"title":"Sending errors through a Formik form","date":"2022-07-22T00:00:00.000Z","draft":false,"tags":["web development","react","formik","tips"],"summary":"Sending validation errors through Formik forms","slug":"tips/sending-errors-formik-form"},"next":null},"__N_SSG":true}