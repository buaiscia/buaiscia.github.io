{"pageProps":{"post":{"mdxSource":"var Component=(()=>{var h=Object.create;var r=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var s=n=>r(n,\"__esModule\",{value:!0});var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),p=(n,e)=>{s(n);for(var o in e)r(n,o,{get:e[o],enumerable:!0})},f=(n,e,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of d(e))!g.call(n,a)&&a!==\"default\"&&r(n,a,{get:()=>e[a],enumerable:!(o=u(e,a))||o.enumerable});return n},y=n=>f(s(r(n!=null?h(m(n)):{},\"default\",n&&n.__esModule&&\"default\"in n?{get:()=>n.default,enumerable:!0}:{value:n,enumerable:!0})),n);var c=b((N,i)=>{i.exports=_jsx_runtime});var j={};p(j,{default:()=>B,frontmatter:()=>w});var t=y(c()),w={title:\"Making reusable get methods in React Testing Library\",date:\"2022-11-16\",draft:!1,tags:[\"web development\",\"react\",\"react testing library\",\"testing\"],summary:\"Creating some abstractions to have ready to use getter functions\"};function l(n){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:`While writing unit and integration tests, I'm trying to find the best way on how to write them cleanly.\nI'm using React Testing Library so that makes already a good job of using good patterns.\nHowever, recently I stumbled upon the fact that I'm reusing again and again the same methods to get the elements from the DOM.`}),`\n`,(0,t.jsxs)(e.p,{children:[\"The majority of cases are using \",(0,t.jsx)(e.code,{children:\"screen.getByRole\"}),\" for the buttons and \",(0,t.jsx)(e.code,{children:\"screen.getByLabelText\"}),\" for the inputs, using the name prop. The only difference would be the first returning the element, and the latter returning the value of the input. Normally, I would use the first one this way:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`screen.getByRole('button', {name: /name of the button/i })\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"As I like to use the names without having to think about capitalization of some letter, I use the parameter 'i' with Regex in order to ignore this case. Also, being with Regex, I don't have to worry whether it's a full sentence or just a part of it.\"}),`\n`,(0,t.jsx)(e.p,{children:\"So, I thought I could extract these methods in a more reusable way, in order to use them freely around the test suites.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Here's how I did it:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const getButtonByName = (btnName) => {\n  const regName = new RegExp(btnName, 'i')\n\n  return screen.getByRole('button', { name: regName })\n}\n\nconst getInputByLabel = (label) => {\n  const regName = new RegExp(label, 'i')\n\n  const { value } = screen.getByLabelText(regName)\n\n  return value\n}\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Then I can easily use them:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`  const button = getButtonByName('my button')\n  const inputValue = getInputByLabel('my input label')\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"I made another method in a similar way for radio buttons. More could be done but these are the three methods I use the most. So for the rest, it could be a little of over-abstraction.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Another improvement that can be done, in my opinion, would be change the strings of the names ('my button', etc.) with fixed objects (JS) or enums (TS). For example:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`JS\n\nconst ButtonNames = Object.freeze({\n\tButtonOne: \"button one\",\n\tButtonTwo: \"button two\",\n})\n\nTS\n\nenum ButtonNames {\n  ButtonOne = \"button one\"\n  ButtonTwo = \"button two\"\n}\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Thank you for reading! Let's connect on \",(0,t.jsx)(e.a,{href:\"https://twitter.com/AlexBuaiscia\",children:\"Twitter\"}),\" or \",(0,t.jsx)(e.a,{href:\"@alex_@uiuxdev.social\",children:\"Mastodon\"}),\"!\"]})]})}function x(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(l,n)})):l(n)}var B=x;return j;})();\n;return Component;","toc":[],"frontMatter":{"readingTime":{"text":"2 min read","minutes":1.995,"time":119700,"words":399},"slug":"tips/make-reusable-get-methods-react-testing-library","fileName":"tips/make-reusable-get-methods-react-testing-library.md","title":"Making reusable get methods in React Testing Library","date":"2022-11-16T00:00:00.000Z","draft":false,"tags":["web development","react","react testing library","testing"],"summary":"Creating some abstractions to have ready to use getter functions"}},"authorDetails":[{"readingTime":{"text":"1 min read","minutes":0.865,"time":51900,"words":173},"slug":["default"],"fileName":"default.md","name":"Alex Buaiscia","avatar":"/static/images/avatar.png","occupation":"Full-stack Software Developer","company":"Atlas Copco","twitter":"https://twitter.com/AlexBuaiscia","linkedin":"https://www.linkedin.com/in/alex-buaiscia/","github":"https://github.com/buaiscia","date":null}],"prev":{"title":"Memoize a React component","date":"2022-07-27T00:00:00.000Z","draft":false,"tags":["web development","react","tips"],"summary":"Using React.memo to memoize a React component","slug":"tips/memoize-react-component"},"next":{"title":"Make a reusable test with React Testing Library","date":"2022-11-22T00:00:00.000Z","draft":false,"tags":["web development","react","react testing library","testing"],"summary":"Abstract methods to be reused by different tests","slug":"tips/make-reusable-test-react-testing-library"}},"__N_SSG":true}