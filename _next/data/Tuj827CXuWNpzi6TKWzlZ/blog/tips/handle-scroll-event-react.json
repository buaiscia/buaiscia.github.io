{"pageProps":{"post":{"mdxSource":"var Component=(()=>{var h=Object.create;var s=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var c=t=>s(t,\"__esModule\",{value:!0});var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),f=(t,e)=>{c(t);for(var o in e)s(t,o,{get:e[o],enumerable:!0})},w=(t,e,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!p.call(t,i)&&i!==\"default\"&&s(t,i,{get:()=>e[i],enumerable:!(o=d(e,i))||o.enumerable});return t},v=t=>w(c(s(t!=null?h(m(t)):{},\"default\",t&&t.__esModule&&\"default\"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var l=g((T,r)=>{r.exports=_jsx_runtime});var I={};f(I,{default:()=>S,frontmatter:()=>y});var n=v(l()),y={title:\"How to Handle Scroll Events in React\",date:\"2023-10-22\",draft:!1,tags:[\"web development\",\"react\"],summary:\"Mastering Smooth Scroll Events in React: A Guide to Debouncing and Dynamic Navigation\"};function a(t){let e=Object.assign({p:\"p\",h2:\"h2\",a:\"a\",pre:\"pre\",code:\"code\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"In this blog post, we\\u2019ll explore how to handle scroll events in a React application. We\\u2019ll focus on an issue developers could face: synchronizing state with the scroll position.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"The Problem\"}),`\n`,(0,n.jsx)(e.p,{children:\"Imagine you\\u2019re building a complex UI with multiple sections, and you want to highlight the navigation link of the section currently visible in the viewport. Not only that, you would like to be able to click on the sections and scroll on the corresponding one. You might think of using a scroll event listener that checks the scroll position and updates the state accordingly.\"}),`\n`,(0,n.jsxs)(e.p,{children:[`However, you may encounter an issue where your state updates continuously, causing unnecessary re-renders and performance issues.\nUnfortunately, the only browser API for it, called `,(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Document/scrollend_event\",children:\"scrollend event\"}),\", is not compatible and implemented in Safari, nor in iOS, Samsung or Opera browsers, so it can't be really used on large scale.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"The Solution: Debouncing\"}),`\n`,(0,n.jsx)(e.p,{children:\"To solve this problem, we can use a technique called debouncing. Debouncing is a programming practice used to ensure that time-consuming tasks do not fire so often. This can be particularly useful for rate limiting execution of handlers on events that will trigger requests.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Here\\u2019s how you could implement a debounce function in TypeScript, in a very abstract method:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`function debounce(func: (...args: any[]) => void, wait: number) {\n  let timeout: NodeJS.Timeout;\n  return function executedFunction(...args: any[]) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n};\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"This debounce function takes two arguments: func, the function you want to debounce, and wait, the number of milliseconds to delay before executing the function.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Checking if an Element is in the Viewport\"}),`\n`,(0,n.jsx)(e.p,{children:\"To determine which section is currently visible in the viewport, we can use a helper function:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`function isElementInViewport(el: HTMLElement) {\n  const rect = el.getBoundingClientRect()\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n    rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n  )\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This function takes a DOM element as an argument and uses the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\",children:\"getBoundingClientRect\"}),\" method to get its position relative to the viewport. It then checks if the entire element (from top to bottom and left to right) is within the viewport dimensions. If it is, the function returns true; otherwise, it returns false.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We can use this function in our scroll event listener to check if each section is in the viewport and update our selected state accordingly.\"}),`\n`,(0,n.jsx)(e.p,{children:\"By combining these techniques, we can create a dynamic navigation system that responds to both user interactions and scroll events, providing a smooth and intuitive user experience.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Applying Debouncing to Scroll Event Listener\"}),`\n`,(0,n.jsx)(e.p,{children:\"We can apply our debounce function to the scroll event listener in our React component:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`useEffect(() => {\n  const handleScroll = debounce(() => {\n    if (!isScrolling) {\n      const sections = document.querySelectorAll('.section')\n      sections.forEach(section => {\n        if (isElementInViewport(section as HTMLElement)) {\n          setSelected(() => section.id)\n        }\n      })\n    }\n  }, 500); // Adjust this value as needed\n\n  window.addEventListener('scroll', handleScroll);\n\n  return () => {\n    window.removeEventListener('scroll', handleScroll);\n  };\n}, [isScrolling]);\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"In this code snippet, we\\u2019re adding a scroll event listener that fires our debounced function. This function checks if we\\u2019re currently scrolling and if not, it checks each section (through a class name to be applied) to see if it\\u2019s in the viewport. If it is, it sets the selected state to the ID of that section.\"}),`\n`,(0,n.jsx)(e.p,{children:\"By using debouncing, we ensure that our event handler doesn\\u2019t fire too often and cause performance issues. Instead, it waits until a certain amount of time has passed without the event being fired before executing.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Handling Click Events\"}),`\n`,(0,n.jsx)(e.p,{children:\"In our React component, we may want to handle click events that trigger scrolling to a specific section. Here\\u2019s how we can do it:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`const handleOnClick = async (value: any) => {\n  setIsScrolling(true)\n\n  const element = document.getElementById(value)\n\n  if (element) {\n    element.scrollIntoView({behavior: 'smooth'})\n\n    setTimeout(() => {\n      setIsScrolling(false)\n      setSelected(() => value)\n    }, 500)\n  }\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"In this function, we\\u2019re first setting isScrolling to true. Then, we\\u2019re getting the DOM element with the ID equal to the clicked value. If such an element exists, we\\u2019re using the scrollIntoView method to smoothly scroll to that element.\"}),`\n`,(0,n.jsx)(e.p,{children:\"After a timeout of 500ms (to allow for the scrolling animation to finish), we\\u2019re setting isScrolling back to false and updating our selected state to the ID of the clicked section.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Simplifying debouncing\"}),`\n`,(0,n.jsx)(e.p,{children:\"It is even possible to use directly the setTimeout browser API directly, instead of making a function about debouncing. The effect, pardon the pun, will be the same, but the code simpler, if you don't need to reuse it. Otherwise, the debounce function, or even import lodash debounce, will do.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`useEffect(() => {\n  let timeout: NodeJS.Timeout\n  \n  const handleScroll = () => {\n    if (timeout) {\n      clearTimeout(timeout)\n    }\n\n    timeout = setTimeout(() => {\n      if (!isScrolling) {\n        const sections = document.querySelectorAll('.section')\n        sections.forEach(section => {\n          if (isElementInViewport(section as HTMLElement)) {\n            setSelected(() => section.id)\n          }\n        })\n      }\n    }, 100) // set to what is your need; can be lower than the handle on click for it doesn't need too much waiting\n  }\n\n  window.addEventListener('scroll', handleScroll);\n\n  return () => {\n    window.removeEventListener('scroll', handleScroll);\n  };\n}, [isScrolling]);\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Conclusion\"}),`\n`,(0,n.jsx)(e.p,{children:`Handling scroll events in React can be tricky due to the asynchronous nature of JavaScript and the way React batches state updates. However, with techniques like debouncing, we can efficiently handle these events and create smooth, responsive user interfaces.\nWhen we have to use two different listeners to make actions on our DOM, they can interfere with each other. That's why we need to create some workaround to wait for the changes to happen.`}),`\n`,(0,n.jsx)(e.p,{children:`Remember to always remove event listeners when they\\u2019re no longer needed to prevent memory leaks and potential performance issues.\nIf you have other ways of handling scroll events in such cases, please share it!`})]})}function b(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(a,t)})):a(t)}var S=b;return I;})();\n;return Component;","toc":[],"frontMatter":{"readingTime":{"text":"6 min read","minutes":5.03,"time":301800,"words":1006},"slug":"tips/handle-scroll-event-react","fileName":"tips/handle-scroll-event-react.md","title":"How to Handle Scroll Events in React","date":"2023-10-22T00:00:00.000Z","draft":false,"tags":["web development","react"],"summary":"Mastering Smooth Scroll Events in React: A Guide to Debouncing and Dynamic Navigation"}},"authorDetails":[{"readingTime":{"text":"1 min read","minutes":0.865,"time":51900,"words":173},"slug":["default"],"fileName":"default.md","name":"Alex Buaiscia","avatar":"/static/images/avatar.png","occupation":"Full-stack Software Developer","company":"Atlas Copco","twitter":"https://twitter.com/AlexBuaiscia","linkedin":"https://www.linkedin.com/in/alex-buaiscia/","github":"https://github.com/buaiscia","date":null}],"prev":{"title":"Types Compatibility issues between Jest and Vitest using React Testing Library and their fix","date":"2023-05-29T00:00:00.000Z","draft":false,"tags":["web development","jest","react-testing-library"],"summary":"Addressing Jest-Vitest Conflict: Fixing Global Type Identifier Errors and Optimizing Build Workflow","slug":"tips/types-issue-jest-vitest"},"next":{"title":"Printing Perfection, A Developer’s Journey with React-to-Print","date":"2023-11-28T00:00:00.000Z","draft":false,"tags":["web development","react"],"summary":"Navigating the Challenges: Implementing a Robust Printing Solution with react-to-print in Web Development","slug":"tips/printing-developer-journey-react-to-print"}},"__N_SSG":true}