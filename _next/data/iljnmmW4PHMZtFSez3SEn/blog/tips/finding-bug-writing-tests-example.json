{"pageProps":{"post":{"mdxSource":"var Component=(()=>{var r=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var h=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var c=a=>o(a,\"__esModule\",{value:!0});var u=(a,s)=>()=>(s||a((s={exports:{}}).exports,s),s.exports),N=(a,s)=>{c(a);for(var t in s)o(a,t,{get:s[t],enumerable:!0})},k=(a,s,t)=>{if(s&&typeof s==\"object\"||typeof s==\"function\")for(let n of d(s))!m.call(a,n)&&n!==\"default\"&&o(a,n,{get:()=>s[n],enumerable:!(t=p(s,n))||t.enumerable});return a},g=a=>k(c(o(a!=null?r(h(a)):{},\"default\",a&&a.__esModule&&\"default\"in a?{get:()=>a.default,enumerable:!0}:{value:a,enumerable:!0})),a);var i=u((v,l)=>{l.exports=_jsx_runtime});var b={};N(b,{default:()=>y,frontmatter:()=>w});var e=g(i()),w={title:\"Finding a bug after writing a test, an example\",date:\"2022-11-30\",draft:!1,tags:[\"web development\",\"react\",\"testing\"],summary:\"I wrote a test and found a small bug. Even in React writing tests is important\"};function f(a={}){let{wrapper:s}=a.components||{};return s?(0,e.jsx)(s,Object.assign({},a,{children:(0,e.jsx)(t,{})})):t();function t(){let n=Object.assign({p:\"p\",pre:\"pre\",code:\"code\",span:\"span\",a:\"a\"},a.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.p,{children:\"In almost every Sprint, at work, I try to reserve some space for solving tech debt and doing some refactoring. A part of resolving this debt is making integration tests. And sometimes it happens that those tests find some unknown bug. That's what happened a few days ago. As usual, the names of the methods and variables are just an example.\"}),(0,e.jsx)(n.p,{children:\"The page I was writing the tests on is a simple one. Some text, three buttons, and nothing more. Yet, it has some hooks as well, defining the logic of those buttons (opening another URL, submitting the form, etc).\"}),(0,e.jsx)(n.p,{children:\"I started writing the tests in the usual way, using React Testing Library. Checking the rendering and the behavior of the page by clicking on the different buttons. When I was writing the test for one of the three buttons, however, it forced me to let me think: is this button always visible? Why?\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsxs)(n.code,{className:\"language-js code-highlight\",children:[(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),\"showButton \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"&&\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"   \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"<\"}),(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"Button\"}),\" onClick\",(0,e.jsx)(n.span,{className:\"token operator\",children:\"=\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),\"onApplyClick\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"}),(0,e.jsx)(n.span,{className:\"token operator\",children:\">\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"      \",(0,e.jsx)(n.span,{className:\"token constant\",children:\"DO\"}),\" \",(0,e.jsx)(n.span,{className:\"token constant\",children:\"THING\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"   \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"<\"}),(0,e.jsx)(n.span,{className:\"token operator\",children:\"/\"}),(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"Button\"}),(0,e.jsx)(n.span,{className:\"token operator\",children:\">\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"}),`\n`]})]})}),(0,e.jsx)(n.p,{children:\"I checked the hooks and found out that it would render only when another property was true, or present. So why it was always there?\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsx)(n.code,{className:\"language-js code-highlight\",children:(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  showButton\",(0,e.jsx)(n.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"!\"}),(0,e.jsx)(n.span,{className:\"token operator\",children:\"!\"}),\"secondaryProp\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),`\n`]})})}),(0,e.jsx)(n.p,{children:\"I followed the source of that property and I came across the point where its data was fetched from the (easy-peasy) store, and then it was set as an initial value of 0, instead of being undefined.\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsxs)(n.code,{className:\"language-js code-highlight\",children:[(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token keyword\",children:\"const\"}),\" initialState\",(0,e.jsx)(n.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(n.span,{className:\"token maybe-class-name\",children:\"IState\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"=\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token operator spread\",children:\"...\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  secondaryProp\",(0,e.jsx)(n.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(n.span,{className:\"token number\",children:\"0\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),`\n`]})]})}),(0,e.jsx)(n.p,{children:'The type of that property was just \"number\", instead of \"number?\". So it was always true.'}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsxs)(n.code,{className:\"language-js code-highlight\",children:[(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token keyword module\",children:\"export\"}),\" \",(0,e.jsx)(n.span,{className:\"token keyword\",children:\"interface\"}),\" \",(0,e.jsx)(n.span,{className:\"token class-name\",children:\"IState\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  secondaryProp\",(0,e.jsx)(n.span,{className:\"token operator\",children:\":\"}),` number\n`]})]})}),(0,e.jsx)(n.p,{children:\"To fix it, I changed the type and set the initial values as undefined.\"}),(0,e.jsx)(n.p,{children:\"Re-checking that property I saw that another value was dependent on it being present or not. So in another hook, I had to redefine the behavior in case the prop was falsy.\"}),(0,e.jsx)(n.pre,{className:\"language-js\",children:(0,e.jsxs)(n.code,{className:\"language-js code-highlight\",children:[(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token keyword\",children:\"const\"}),\" newUrl \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"=\"}),\" secondaryProp \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"&&\"}),\" \",(0,e.jsxs)(n.span,{className:\"token template-string\",children:[(0,e.jsx)(n.span,{className:\"token string template-punctuation\",children:\"`\"}),(0,e.jsxs)(n.span,{className:\"token interpolation\",children:[(0,e.jsx)(n.span,{className:\"token punctuation interpolation-punctuation\",children:\"${\"}),(0,e.jsx)(n.span,{className:\"token constant\",children:\"FETCHED_URL\"}),(0,e.jsx)(n.span,{className:\"token punctuation interpolation-punctuation\",children:\"}\"})]}),(0,e.jsx)(n.span,{className:\"token string\",children:\"/prop=\"}),(0,e.jsxs)(n.span,{className:\"token interpolation\",children:[(0,e.jsx)(n.span,{className:\"token punctuation interpolation-punctuation\",children:\"${\"}),\"secondaryProp\",(0,e.jsx)(n.span,{className:\"token punctuation interpolation-punctuation\",children:\"}\"})]}),(0,e.jsx)(n.span,{className:\"token string template-punctuation\",children:\"`\"})]}),`\n`]}),(0,e.jsx)(n.span,{className:\"code-line\",children:`\n`}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token keyword\",children:\"const\"}),\" \",(0,e.jsx)(n.span,{className:\"token function function-variable\",children:\"onClick\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"=\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,e.jsx)(n.span,{className:\"token operator arrow\",children:\"=>\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"    \",(0,e.jsx)(n.span,{className:\"token keyword control-flow\",children:\"if\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(n.span,{className:\"token operator\",children:\"!\"}),\"newUrl\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"      \",(0,e.jsx)(n.span,{className:\"token keyword control-flow\",children:\"return\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"    \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"}),`\n`]}),(0,e.jsx)(n.span,{className:\"code-line\",children:`\n`}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"    \",(0,e.jsx)(n.span,{className:\"token dom variable\",children:\"window\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(n.span,{className:\"token function method property-access\",children:\"open\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),\"newUrl\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"}),`\n`]})]})}),(0,e.jsx)(n.p,{children:\"So that's an interesting case of how making tests helps you reflect on what the behavior, and the logic of the methods and components, should be.\"}),(0,e.jsxs)(n.p,{children:[\"Thank you for reading! Let's connect on \",(0,e.jsx)(n.a,{href:\"https://twitter.com/AlexBuaiscia\",children:\"Twitter\"}),\" or \",(0,e.jsx)(n.a,{href:\"@alex_@uiuxdev.social\",children:\"Mastodon\"}),\"!\"]})]})}}var y=f;return b;})();\n;return Component;","toc":[],"frontMatter":{"readingTime":{"text":"3 min read","minutes":2.53,"time":151800,"words":506},"slug":"tips/finding-bug-writing-tests-example","fileName":"tips/finding-bug-writing-tests-example.md","title":"Finding a bug after writing a test, an example","date":"2022-11-30T00:00:00.000Z","draft":false,"tags":["web development","react","testing"],"summary":"I wrote a test and found a small bug. Even in React writing tests is important"}},"authorDetails":[{"readingTime":{"text":"1 min read","minutes":0.94,"time":56400,"words":188},"slug":["default"],"fileName":"default.md","name":"Alex Buaiscia","avatar":"/static/images/avatar.png","occupation":"Full-stack Software Developer","company":"Moravio","twitter":"https://twitter.com/AlexBuaiscia","linkedin":"https://www.linkedin.com/in/alex-buaiscia/","github":"https://github.com/buaiscia","date":null}],"prev":{"title":"Make a reusable test with React Testing Library","date":"2022-11-22T00:00:00.000Z","draft":false,"tags":["web development","react","react testing library","testing"],"summary":"Abstract methods to be reused by different tests","slug":"tips/make-reusable-test-react-testing-library"},"next":{"title":"Reduce your Jest tests running time (especially on hooks!) with the maxWorkers option'","date":"2022-12-08T00:00:00.000Z","draft":false,"tags":["web development","jest","testing"],"summary":"How tweaking the maxWorkers option can increase tests efficiency","slug":"tips/reduce-jest-tests-running-time-maxworkers"}},"__N_SSG":true}